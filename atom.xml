<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江东的博客</title>
  
  <subtitle>Be overcome difficulties is victory</subtitle>
  <link href="https://du2279664786.github.io/atom.xml" rel="self"/>
  
  <link href="https://du2279664786.github.io/"/>
  <updated>2022-10-16T13:51:48.053Z</updated>
  <id>https://du2279664786.github.io/</id>
  
  <author>
    <name>xiaopi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://du2279664786.github.io/2022/10/15/hello-world/"/>
    <id>https://du2279664786.github.io/2022/10/15/hello-world/</id>
    <published>2022-10-15T03:00:57.930Z</published>
    <updated>2022-10-16T13:51:48.053Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，这是我的第一篇文章，欢迎查看！</p><span id="more"></span><div id="binft"></div>  <script>    var binft = function (r) {      function t() {        return b[Math.floor(Math.random() * b.length)]      }        function e() {        return String.fromCharCode(94 * Math.random() + 33)      }      function n(r) {        for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {          var l = document.createElement("span");          l.textContent = e(), l.style.color = t(), n.appendChild(l)        }        return n      }      function i() {        var t = o[c.skillI];        c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)      }      var l = "",      o = ["青青陵上柏，磊磊涧中石。", "人生天地间，忽如远行客。","斗酒相娱乐，聊厚不为薄。", "驱车策驽马，游戏宛与洛。","洛中何郁郁，冠带自相索。","长衢罗夹巷，王侯多第宅。","两宫遥相望，双阙百余尺。","极宴娱心意，戚戚何所迫？"].map(function (r) {      return r + ""      }),      a = 2,      g = 1,      s = 5,      d = 75,      b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],      c = {        text: "",        prefixP: -s,        skillI: 0,        skillP: 0,        direction: "forward",        delay: a,        step: g      };      i()      };      binft(document.getElementById('binft'));  </script><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，这是我的第一篇文章，欢迎查看！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯+拉普拉斯平滑代码实现-方法二</title>
    <link href="https://du2279664786.github.io/2021/11/13/2021-11-13%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF+%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B9%B3%E6%BB%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-%E6%96%B9%E6%B3%95%E4%BA%8C/"/>
    <id>https://du2279664786.github.io/2021/11/13/2021-11-13%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF+%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B9%B3%E6%BB%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-%E6%96%B9%E6%B3%95%E4%BA%8C/</id>
    <published>2021-11-13T14:55:10.000Z</published>
    <updated>2022-10-16T13:46:44.152Z</updated>
    
    <content type="html"><![CDATA[<p>朴素贝叶斯有多种实现方式，这是另一种实现方式！</p><span id="more"></span><h2 id="首先导入包："><a href="#首先导入包：" class="headerlink" title="首先导入包："></a>首先导入包：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> scorer</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="数据的读取："><a href="#数据的读取：" class="headerlink" title="数据的读取："></a>数据的读取：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">datasets = pd.DataFrame([[<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;硬挺&quot;</span>, <span class="string">&quot;清脆&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;硬挺&quot;</span>, <span class="string">&quot;清脆&quot;</span>, <span class="string">&quot;模糊&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;模糊&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;模糊&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>]],</span><br><span class="line">                        columns=[<span class="string">&quot;色泽&quot;</span>, <span class="string">&quot;根蒂&quot;</span>, <span class="string">&quot;敲声&quot;</span>, <span class="string">&quot;纹理&quot;</span>, <span class="string">&quot;脐部&quot;</span>, <span class="string">&quot;触感&quot;</span>, <span class="string">&quot;好瓜&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="计算出好瓜的概率："><a href="#计算出好瓜的概率：" class="headerlink" title="计算出好瓜的概率："></a>计算出好瓜的概率：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fit_fun</span>(<span class="params">datasets</span>):</span><br><span class="line">    good_el_dic = &#123;&#125;   <span class="comment"># P(*|好瓜)</span></span><br><span class="line">    bad_el_dic = &#123;&#125;   <span class="comment"># P(*|坏瓜)</span></span><br><span class="line">    P_dic = &#123;&#125;   <span class="comment"># P(*)</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> datasets.columns.to_list()[<span class="number">0</span>:-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> datasets[j].unique():</span><br><span class="line"><span class="comment">#             P_dic[i] = round((datasets[j].value_counts()[i]+1)/(len(datasets)+len(datasets[j].unique())), 2)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;是&quot;</span> <span class="keyword">in</span> datasets.groupby(j)[<span class="string">&quot;好瓜&quot;</span>].value_counts()[i]:</span><br><span class="line">                good_el_dic[i] = <span class="built_in">round</span>((datasets.groupby(j)[<span class="string">&quot;好瓜&quot;</span>].value_counts()[i][<span class="string">&quot;是&quot;</span>]+<span class="number">1</span>)/(<span class="built_in">len</span>(datasets[datasets[<span class="string">&quot;好瓜&quot;</span>] == <span class="string">&quot;是&quot;</span>])+<span class="built_in">len</span>(datasets[j].unique())), <span class="number">3</span>)      <span class="comment"># 拉普拉斯</span></span><br><span class="line"><span class="comment">#                 good_el_dic[i] = round((datasets.groupby(j)[&quot;好瓜&quot;].value_counts()[i][&quot;是&quot;]+1)/(datasets[j].value_counts()[i]+len(datasets[j].unique())), 2)      # 拉普拉斯</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"><span class="comment">#                 good_el_dic[i] = round(1/(datasets[j].value_counts()[i]+len(datasets[j].unique())), 2)    # 拉普拉斯</span></span><br><span class="line">                good_el_dic[i] = <span class="built_in">round</span>(<span class="number">1</span>/(<span class="built_in">len</span>(datasets[datasets[<span class="string">&quot;好瓜&quot;</span>] == <span class="string">&quot;是&quot;</span>])+<span class="built_in">len</span>(datasets[j].unique())), <span class="number">3</span>)    <span class="comment"># 拉普拉斯</span></span><br><span class="line">    P_good = <span class="built_in">round</span>((<span class="built_in">len</span>(datasets[datasets[<span class="string">&quot;好瓜&quot;</span>] == <span class="string">&quot;是&quot;</span>])+<span class="number">1</span>)/(<span class="built_in">len</span>(datasets)+<span class="number">2</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;P(*|好瓜):&quot;</span>, good_el_dic)</span><br><span class="line"><span class="comment">#     print(&quot;\nP(*):&quot;, P_dic)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nP:&quot;</span>, P_good)</span><br><span class="line">    <span class="keyword">return</span> good_el_dic, P_dic, P_good</span><br><span class="line">good_el_dic, P_dic, P = fit_fun(datasets)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(*|好瓜): &#123;<span class="string">&#x27;青绿&#x27;</span>: <span class="number">0.364</span>, <span class="string">&#x27;乌黑&#x27;</span>: <span class="number">0.455</span>, <span class="string">&#x27;浅白&#x27;</span>: <span class="number">0.182</span>, <span class="string">&#x27;蜷缩&#x27;</span>: <span class="number">0.545</span>, <span class="string">&#x27;稍蜷&#x27;</span>: <span class="number">0.364</span>, <span class="string">&#x27;硬挺&#x27;</span>: <span class="number">0.091</span>, <span class="string">&#x27;浊响&#x27;</span>: <span class="number">0.636</span>, <span class="string">&#x27;沉闷&#x27;</span>: <span class="number">0.273</span>, <span class="string">&#x27;清脆&#x27;</span>: <span class="number">0.091</span>, <span class="string">&#x27;清晰&#x27;</span>: <span class="number">0.727</span>, <span class="string">&#x27;稍糊&#x27;</span>: <span class="number">0.182</span>, <span class="string">&#x27;模糊&#x27;</span>: <span class="number">0.091</span>, <span class="string">&#x27;凹陷&#x27;</span>: <span class="number">0.545</span>, <span class="string">&#x27;稍凹&#x27;</span>: <span class="number">0.364</span>, <span class="string">&#x27;平坦&#x27;</span>: <span class="number">0.091</span>, <span class="string">&#x27;硬滑&#x27;</span>: <span class="number">0.7</span>, <span class="string">&#x27;软粘&#x27;</span>: <span class="number">0.3</span>&#125;</span><br><span class="line"></span><br><span class="line">P: <span class="number">0.47</span></span><br></pre></td></tr></table></figure><h2 id="计算坏瓜的概率："><a href="#计算坏瓜的概率：" class="headerlink" title="计算坏瓜的概率："></a>计算坏瓜的概率：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fit_fun</span>(<span class="params">datasets</span>):</span><br><span class="line"><span class="comment">#     good_el_dic = &#123;&#125;   # P(*|好瓜)</span></span><br><span class="line">    bad_el_dic = &#123;&#125;   <span class="comment"># P(*|坏瓜)</span></span><br><span class="line"><span class="comment">#     P_dic = &#123;&#125;   # P(*)</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> datasets.columns.to_list()[<span class="number">0</span>:-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> datasets[j].unique():</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;否&quot;</span> <span class="keyword">in</span> datasets.groupby(j)[<span class="string">&quot;好瓜&quot;</span>].value_counts()[i]:</span><br><span class="line"><span class="comment">#                 bad_el_dic[i] = round((datasets.groupby(j)[&quot;好瓜&quot;].value_counts()[i][&quot;否&quot;]+1)/(datasets[j].value_counts()[i]+len(datasets[j].unique())), 2)    # 平滑</span></span><br><span class="line">               bad_el_dic[i] = <span class="built_in">round</span>((datasets.groupby(j)[<span class="string">&quot;好瓜&quot;</span>].value_counts()[i][<span class="string">&quot;否&quot;</span>]+<span class="number">1</span>)/(<span class="built_in">len</span>(datasets[datasets[<span class="string">&quot;好瓜&quot;</span>] == <span class="string">&quot;否&quot;</span>])+<span class="built_in">len</span>(datasets[j].unique())), <span class="number">3</span>) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"><span class="comment">#                 P_bad[i] = round(1/(datasets[j].value_counts()[i]+len(datasets[j].unique())), 2)      # 平滑</span></span><br><span class="line">                P_bad[i] = <span class="built_in">round</span>(<span class="number">1</span>/(<span class="built_in">len</span>(datasets[datasets[<span class="string">&quot;好瓜&quot;</span>] == <span class="string">&quot;否&quot;</span>])+<span class="built_in">len</span>(datasets[j].unique())), <span class="number">3</span>)      <span class="comment"># 平滑</span></span><br><span class="line">    P_bad = <span class="built_in">round</span>((<span class="built_in">len</span>(datasets[datasets[<span class="string">&quot;好瓜&quot;</span>] == <span class="string">&quot;否&quot;</span>])+<span class="number">1</span>)/(<span class="built_in">len</span>(datasets)+<span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;P(*|坏瓜):&quot;</span>, bad_el_dic)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nP_bad:&quot;</span>, P_bad)</span><br><span class="line">    <span class="keyword">return</span> bad_el_dic, P_bad</span><br><span class="line">bad_el_dic, P_bad = fit_fun(datasets)</span><br><span class="line">P_ = <span class="number">1</span>-P</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(*|坏瓜): &#123;<span class="string">&#x27;青绿&#x27;</span>: <span class="number">0.333</span>, <span class="string">&#x27;乌黑&#x27;</span>: <span class="number">0.25</span>, <span class="string">&#x27;浅白&#x27;</span>: <span class="number">0.417</span>, <span class="string">&#x27;蜷缩&#x27;</span>: <span class="number">0.333</span>, <span class="string">&#x27;稍蜷&#x27;</span>: <span class="number">0.417</span>, <span class="string">&#x27;硬挺&#x27;</span>: <span class="number">0.25</span>, <span class="string">&#x27;浊响&#x27;</span>: <span class="number">0.417</span>, <span class="string">&#x27;沉闷&#x27;</span>: <span class="number">0.333</span>, <span class="string">&#x27;清脆&#x27;</span>: <span class="number">0.25</span>, <span class="string">&#x27;清晰&#x27;</span>: <span class="number">0.25</span>, <span class="string">&#x27;稍糊&#x27;</span>: <span class="number">0.417</span>, <span class="string">&#x27;模糊&#x27;</span>: <span class="number">0.333</span>, <span class="string">&#x27;凹陷&#x27;</span>: <span class="number">0.25</span>, <span class="string">&#x27;稍凹&#x27;</span>: <span class="number">0.333</span>, <span class="string">&#x27;平坦&#x27;</span>: <span class="number">0.417</span>, <span class="string">&#x27;硬滑&#x27;</span>: <span class="number">0.636</span>, <span class="string">&#x27;软粘&#x27;</span>: <span class="number">0.364</span>&#125;</span><br><span class="line"></span><br><span class="line">P_bad: <span class="number">0.526</span></span><br></pre></td></tr></table></figure><h2 id="单个数据的预测："><a href="#单个数据的预测：" class="headerlink" title="单个数据的预测："></a>单个数据的预测：</h2><p>好瓜概率预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>]</span><br><span class="line">P_good = P</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test:</span><br><span class="line"><span class="comment">#     P_good = P_good*good_el_dic[i]*P_dic[i]/P</span></span><br><span class="line">    P_good = P_good*good_el_dic[i]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测为好瓜的概率：&quot;</span>, P_good )</span><br><span class="line"><span class="comment"># 预测为坏瓜的概率： 0.0006981899836275</span></span><br></pre></td></tr></table></figure><p>坏瓜概率预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P_bad = P_</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test:</span><br><span class="line"><span class="comment">#     P_bad = P_bad*bad_el_dic[i]*P_dic[i]/P_</span></span><br><span class="line">    P_bad = P_bad*bad_el_dic[i]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测为坏瓜的概率：&quot;</span>, P_bad)</span><br><span class="line"><span class="comment"># 预测为坏瓜的概率： 0.0006981899836275</span></span><br></pre></td></tr></table></figure><h2 id="整体预测："><a href="#整体预测：" class="headerlink" title="整体预测："></a>整体预测：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">y_pre = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(datasets)):</span><br><span class="line">    test = datasets.iloc[i, :<span class="number">0</span>-<span class="number">1</span>].to_list()</span><br><span class="line">    P_g = P</span><br><span class="line">    P_b = P_</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test:</span><br><span class="line"><span class="comment">#         P_g = P_g*good_el_dic[i]*P_dic[i]/P</span></span><br><span class="line">        P_g = P_g*good_el_dic[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test:</span><br><span class="line"><span class="comment">#         P_b = P_b*bad_el_dic[i]*P_dic[i]/P_</span></span><br><span class="line">        P_b = P_b*bad_el_dic[i]</span><br><span class="line">    <span class="keyword">if</span> P_g&gt;P_b:</span><br><span class="line">        y_pre.append(<span class="string">&quot;是&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_pre.append(<span class="string">&quot;否&quot;</span>)</span><br><span class="line">y_test = datasets[<span class="string">&quot;好瓜&quot;</span>]</span><br><span class="line">y_test==pd.Series(y_pre)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">4</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">5</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">7</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">8</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">9</span>      <span class="literal">True</span></span><br><span class="line"><span class="number">10</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">11</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">12</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">13</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">14</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">15</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">16</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><p>如有大佬看出错误，请指正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朴素贝叶斯有多种实现方式，这是另一种实现方式！&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="朴素贝叶斯" scheme="https://du2279664786.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>手撕代码：朴素贝叶斯+拉普拉斯平滑代码实现</title>
    <link href="https://du2279664786.github.io/2021/11/12/2021-11-12%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF+%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B9%B3%E6%BB%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://du2279664786.github.io/2021/11/12/2021-11-12%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF+%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B9%B3%E6%BB%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-12T14:55:10.000Z</published>
    <updated>2022-10-16T13:44:49.448Z</updated>
    
    <content type="html"><![CDATA[<p>通过底层逻辑去复现贝叶斯代码</p><span id="more"></span><h3 id="计算步骤："><a href="#计算步骤：" class="headerlink" title="计算步骤："></a>计算步骤：</h3><p>P(好瓜) &#x3D; P(好瓜)P(色泽|好瓜)P(根蒂|好瓜)P(敲声|好瓜)P(纹理|好瓜)P(脐部|好瓜)P(触感|好瓜)<br>P(坏瓜) &#x3D; P(坏瓜)P(色泽|坏瓜)P(根蒂|坏瓜)P(敲声|坏瓜)P(纹理|坏瓜)P(脐部|坏瓜)P(触感|坏瓜)<br>例：P(色泽|好瓜) &#x3D; P(好瓜|色泽)*P(色泽)&#x2F;P(好瓜)</p><h3 id="数据的读取"><a href="#数据的读取" class="headerlink" title="数据的读取"></a>数据的读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># melon2 = pd.read_csv(&#x27;E:\\work\ml\\Python_Project_01\\sklearn_week\\week_10\\melon2.0.csv&#x27;, index_col=&#x27;编号&#x27;)</span></span><br><span class="line"></span><br><span class="line">melon2 = pd.DataFrame([[<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;是&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;硬挺&quot;</span>, <span class="string">&quot;清脆&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;硬挺&quot;</span>, <span class="string">&quot;清脆&quot;</span>, <span class="string">&quot;模糊&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;模糊&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;凹陷&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;乌黑&quot;</span>, <span class="string">&quot;稍蜷&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;清晰&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;软粘&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;浅白&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;浊响&quot;</span>, <span class="string">&quot;模糊&quot;</span>, <span class="string">&quot;平坦&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>],</span><br><span class="line">                         [<span class="string">&quot;青绿&quot;</span>, <span class="string">&quot;蜷缩&quot;</span>, <span class="string">&quot;沉闷&quot;</span>, <span class="string">&quot;稍糊&quot;</span>, <span class="string">&quot;稍凹&quot;</span>, <span class="string">&quot;硬滑&quot;</span>, <span class="string">&quot;否&quot;</span>]],</span><br><span class="line">                        columns=[<span class="string">&quot;色泽&quot;</span>, <span class="string">&quot;根蒂&quot;</span>, <span class="string">&quot;敲声&quot;</span>, <span class="string">&quot;纹理&quot;</span>, <span class="string">&quot;脐部&quot;</span>, <span class="string">&quot;触感&quot;</span>, <span class="string">&quot;好瓜&quot;</span>])</span><br></pre></td></tr></table></figure><h3 id="取好坏瓜："><a href="#取好坏瓜：" class="headerlink" title="取好坏瓜："></a>取好坏瓜：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m2_bad = melon2[melon2[<span class="string">&#x27;好瓜&#x27;</span>] == <span class="string">&#x27;否&#x27;</span>]</span><br><span class="line">m2_good = melon2[melon2[<span class="string">&#x27;好瓜&#x27;</span>] == <span class="string">&#x27;是&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="求先验："><a href="#求先验：" class="headerlink" title="求先验："></a>求先验：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 好不好的先验</span></span><br><span class="line">p_good_priori = (<span class="built_in">len</span>(m2_good) + <span class="number">1</span>) / (<span class="built_in">len</span>(melon2) + <span class="number">2</span>)</span><br><span class="line">p_bad_priori = (<span class="built_in">len</span>(m2_bad) + <span class="number">1</span>) / (<span class="built_in">len</span>(melon2) + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="特征提取："><a href="#特征提取：" class="headerlink" title="特征提取："></a>特征提取：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 各个特征的好、不好的拉普拉斯平滑：使用列表作为整体，每个特征实现一个字典</span></span><br><span class="line"><span class="comment"># 计数每个特征的值类别数</span></span><br><span class="line">feature_num = melon2.shape[-<span class="number">1</span>] - <span class="number">1</span>  <span class="comment"># 全局性隐含特征序一致</span></span><br><span class="line">features_name = []  <span class="comment"># 特征的值的集合，这里一致，然后防止好瓜、坏瓜中没有相关的特征值</span></span><br><span class="line">features_counts = []  <span class="comment"># 特征的个数，可以拉普拉斯平滑的分母修正项</span></span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">    features_name.append(<span class="built_in">set</span>(melon2.iloc[:, ii]))</span><br><span class="line">    features_counts.append(<span class="built_in">len</span>(<span class="built_in">set</span>(melon2.iloc[:, ii]))</span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">features_name</span><br><span class="line">[&#123;<span class="string">&#x27;乌黑&#x27;</span>, <span class="string">&#x27;浅白&#x27;</span>, <span class="string">&#x27;青绿&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;硬挺&#x27;</span>, <span class="string">&#x27;稍蜷&#x27;</span>, <span class="string">&#x27;蜷缩&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;沉闷&#x27;</span>, <span class="string">&#x27;浊响&#x27;</span>, <span class="string">&#x27;清脆&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;模糊&#x27;</span>, <span class="string">&#x27;清晰&#x27;</span>, <span class="string">&#x27;稍糊&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;凹陷&#x27;</span>, <span class="string">&#x27;平坦&#x27;</span>, <span class="string">&#x27;稍凹&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;硬滑&#x27;</span>, <span class="string">&#x27;软粘&#x27;</span>&#125;]</span><br><span class="line"> </span><br><span class="line">features_counts：[<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求P-好瓜-："><a href="#求P-好瓜-：" class="headerlink" title="求P(*|好瓜)："></a>求P(*|好瓜)：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 好瓜部分</span></span><br><span class="line">ps_feature_good = []</span><br><span class="line"><span class="comment"># 先对特征计数</span></span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">    ps_feature_good.append(<span class="built_in">dict</span>(m2_good.iloc[:, ii].value_counts()))  <span class="comment"># Series本质上就是字典</span></span><br><span class="line"><span class="comment"># 然后用拉普拉斯计算条件概率</span></span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">    <span class="keyword">for</span> ff <span class="keyword">in</span> features_name[ii]:  <span class="comment"># 下一行的get防止出空</span></span><br><span class="line">        ps_feature_good[ii][ff] = (ps_feature_good[ii].get(ff, <span class="number">0</span>) + <span class="number">1</span>) / (<span class="built_in">len</span>(m2_good) + features_counts[ii])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求P-坏瓜-："><a href="#求P-坏瓜-：" class="headerlink" title="求P(*|坏瓜)："></a>求P(*|坏瓜)：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 坏瓜部分</span><br><span class="line">ps_feature_bad = []</span><br><span class="line"># 先对特征计数</span><br><span class="line">for ii in range(feature_num):</span><br><span class="line">    ps_feature_bad.append(dict(m2_bad.iloc[:, ii].value_counts()))</span><br><span class="line"># 然后用拉普拉斯计算条件概率</span><br><span class="line">for ii in range(feature_num):</span><br><span class="line">    for ff in features_name[ii]:</span><br><span class="line">        ps_feature_bad[ii][ff] = (ps_feature_bad[ii].get(ff, 0) + 1) / (len(m2_bad) + features_counts[ii])</span><br></pre></td></tr></table></figure><h3 id="预测好坏瓜的函数："><a href="#预测好坏瓜的函数：" class="headerlink" title="预测好坏瓜的函数："></a>预测好坏瓜的函数：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 预测的函数 好坏分开，连乘比大小</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">features</span>):</span><br><span class="line">    p_good = p_good_priori</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">        p_good *= ps_feature_good[ii][features[ii]]</span><br><span class="line"></span><br><span class="line">    p_bad = p_bad_priori</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">        p_bad *= ps_feature_bad[ii][features[ii]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;是&#x27;</span> <span class="keyword">if</span> p_good &gt; p_bad <span class="keyword">else</span> <span class="string">&#x27;否&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="验证结果："><a href="#验证结果：" class="headerlink" title="验证结果："></a>验证结果：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证结果</span></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> melon2.index:</span><br><span class="line">    <span class="built_in">print</span>(predict(melon2.loc[idx]), melon2.loc[idx][-<span class="number">1</span>],</span><br><span class="line">          predict(melon2.loc[idx]) == melon2.loc[idx][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">否 是 <span class="literal">False</span></span><br><span class="line">是 是 <span class="literal">True</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br><span class="line">是 否 <span class="literal">False</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br><span class="line">是 否 <span class="literal">False</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br><span class="line">否 否 <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这是老师给的代码，下一篇文章介绍本人自己的写的代码，欢迎阅读</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过底层逻辑去复现贝叶斯代码&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="朴素贝叶斯" scheme="https://du2279664786.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>感知机对偶形式</title>
    <link href="https://du2279664786.github.io/2021/11/11/2021-11-11%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F/"/>
    <id>https://du2279664786.github.io/2021/11/11/2021-11-11%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F/</id>
    <published>2021-11-11T14:55:10.000Z</published>
    <updated>2022-10-16T13:43:02.867Z</updated>
    
    <content type="html"><![CDATA[<p>对偶形式的学习</p><span id="more"></span><h1 id="感知机："><a href="#感知机：" class="headerlink" title="感知机："></a>感知机：</h1><p><img src="https://img-blog.csdnimg.cn/8bc509286c3641a7844f284216f720c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>符号函数：<br><img src="https://img-blog.csdnimg.cn/70e40fdefc484089b822a8efec34ef22.png" alt="在这里插入图片描述"><br>选择误分类点到超平面的总距离作为损失函数：<br>距离：<br><img src="https://img-blog.csdnimg.cn/b1e8233735eb44b099e77ebd0fbd5039.png" alt="在这里插入图片描述"><br>误分类点：<br><img src="https://img-blog.csdnimg.cn/c6ba2a3255ed4545a2ad4ebef007366c.png" alt="在这里插入图片描述"><br>误分类点距离<br><img src="https://img-blog.csdnimg.cn/d5e075fd4b8a4e07b2c1d9a32085a4cd.png" alt="在这里插入图片描述"><br>总距离<br><img src="https://img-blog.csdnimg.cn/e602a94564984d83b108933a75d65d56.png" alt="在这里插入图片描述"></p><h1 id="感知机对偶形式"><a href="#感知机对偶形式" class="headerlink" title="感知机对偶形式"></a>感知机对偶形式</h1><p><img src="https://img-blog.csdnimg.cn/ef771d364c0a4ff88c004cfda93efa9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/226ce69ae78345b89b95eba252209fb2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>过程<br><img src="https://img-blog.csdnimg.cn/96b18946a7994e6cb89953132231d9bf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>例题：<br><img src="https://img-blog.csdnimg.cn/4c91b3714bf44ecb9aa30e3a28050ab7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/71b991ddbe554e1cadcacac1591c4a3e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>动态可视化代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以半动画的方式展示感知识机对偶问题的操作的合理性</span></span><br><span class="line"><span class="comment"># 给定初始点， 初始直线</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=<span class="string">&#x27;sans-serif&#x27;</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmap_light = ListedColormap([<span class="string">&#x27;#FFAAAA&#x27;</span>, <span class="string">&#x27;#AAFFAA&#x27;</span>, <span class="string">&#x27;#AAAAFF&#x27;</span>])</span><br><span class="line">cmap_bold = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#00FF00&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化展示</span></span><br><span class="line">point_coordinates = np.array([<span class="number">2.</span>, <span class="number">2.</span>])  <span class="comment"># 关键点坐标</span></span><br><span class="line"></span><br><span class="line">line_a, line_b = <span class="number">7</span>, <span class="number">9</span>  <span class="comment"># 初始线方程</span></span><br><span class="line">line_c = - line_b * line_a  <span class="comment"># 注意负号</span></span><br><span class="line"></span><br><span class="line">bottom, up = -<span class="number">5</span>, <span class="number">10</span>  <span class="comment"># 视窗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键点对应的“基线”的方程的分类，以平面展示</span></span><br><span class="line">xx_plane = np.linspace(bottom - <span class="number">0.5</span>, up + <span class="number">0.5</span>, <span class="number">300</span>)</span><br><span class="line">yy_plane = np.linspace(bottom - <span class="number">0.5</span>, up + <span class="number">0.5</span>, <span class="number">300</span>)</span><br><span class="line">xx_plane, yy_plane = np.meshgrid(xx_plane, yy_plane)</span><br><span class="line">class_plane = np.array([<span class="number">1</span> <span class="keyword">if</span> np.dot(xi, point_coordinates) + <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">    xx_plane.ravel(), yy_plane.ravel())]).reshape(xx_plane.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化方程对应的分类，以整数点展示</span></span><br><span class="line">dots = np.array([np.array([ii, jj]) <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(bottom, up + <span class="number">1</span>) <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(bottom, up + <span class="number">1</span>)</span><br><span class="line">                 <span class="keyword">if</span> ii != point_coordinates[<span class="number">0</span>] <span class="keyword">or</span> jj != point_coordinates[<span class="number">1</span>]])</span><br><span class="line">class_dots = np.array([<span class="number">1</span> <span class="keyword">if</span> np.dot(xi, [line_a, line_b]) + line_c &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> dots])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到直线在视窗内的两个顶点  直线与视窗四线的交点的中间的两个</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">window_cross</span>(<span class="params">line_a, line_b, line_c</span>):</span><br><span class="line">    <span class="keyword">if</span> line_a == <span class="number">0</span> <span class="keyword">and</span> line_b ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> line_a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (bottom, -line_c / line_b), (up,  -line_c / line_b)</span><br><span class="line">    <span class="keyword">elif</span> line_b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (-line_c / line_a, bottom), (-line_c / line_a, up)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c1 = bottom, - <span class="number">1</span> / line_b * (line_c + line_a * bottom)</span><br><span class="line">        c2 = up, - <span class="number">1</span> / line_b * (line_c + line_a * up)</span><br><span class="line">        c3 = -<span class="number">1</span> / line_a * (line_c + line_b * bottom), bottom</span><br><span class="line">        c4 = -<span class="number">1</span> / line_a * (line_c + line_b * up), up</span><br><span class="line">        cross_points = [c1, c2, c3, c4]</span><br><span class="line">        cross_points.sort()</span><br><span class="line">        <span class="keyword">return</span> cross_points[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始状态展示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.title(<span class="string">&#x27;起始状态 同向&#x27;</span>)</span><br><span class="line">plt.pcolormesh(xx_plane, yy_plane, class_plane, cmap=cmap_light)</span><br><span class="line">plt.scatter(dots[:, <span class="number">0</span>], dots[:, <span class="number">1</span>], c=class_dots, cmap=cmap_bold)</span><br><span class="line">color_point = <span class="string">&#x27;b&#x27;</span> <span class="keyword">if</span> point_coordinates[<span class="number">0</span>] * line_a + point_coordinates[<span class="number">1</span>] * line_b + line_c &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;r&#x27;</span></span><br><span class="line">plt.scatter(point_coordinates[<span class="number">0</span>], point_coordinates[<span class="number">1</span>], c=color_point, marker=<span class="string">&quot;v&quot;</span>, s=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># plt.grid()</span></span><br><span class="line">plt.plot([bottom - <span class="number">0.5</span>, up + <span class="number">0.5</span>], [<span class="number">0</span>, <span class="number">0</span>], c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">0</span>], [bottom - <span class="number">0.5</span>, up + <span class="number">0.5</span>], c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">cross = window_cross(line_a, line_b, line_c)</span><br><span class="line">plt.plot([cross[<span class="number">0</span>][<span class="number">0</span>], cross[<span class="number">1</span>][<span class="number">0</span>]], [cross[<span class="number">0</span>][<span class="number">1</span>], cross[<span class="number">1</span>][<span class="number">1</span>]], c=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代过程的动态展示</span></span><br><span class="line">plt.close(<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    plt.cla()</span><br><span class="line">    plt.title(<span class="string">f&#x27;epoch=<span class="subst">&#123;ii+<span class="number">1</span>&#125;</span>: (<span class="subst">&#123;line_a&#125;</span>) * x + (<span class="subst">&#123;line_b&#125;</span>) * y + (<span class="subst">&#123;line_c&#125;</span>) = 0&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> ii &lt; <span class="number">8</span>:</span><br><span class="line">        time.sleep(<span class="number">0.4</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    plt.pcolormesh(xx_plane, yy_plane, class_plane, cmap=cmap_light)</span><br><span class="line">    plt.scatter(dots[:, <span class="number">0</span>], dots[:, <span class="number">1</span>], c=class_dots, cmap=cmap_bold)</span><br><span class="line">    color_point = <span class="string">&#x27;b&#x27;</span> <span class="keyword">if</span> point_coordinates[<span class="number">0</span>] * line_a + point_coordinates[<span class="number">1</span>] * line_b + line_c &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;r&#x27;</span></span><br><span class="line">    plt.scatter(point_coordinates[<span class="number">0</span>], point_coordinates[<span class="number">1</span>], c=color_point, marker=<span class="string">&quot;v&quot;</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.plot([bottom - <span class="number">0.5</span>, up + <span class="number">0.5</span>], [<span class="number">0</span>, <span class="number">0</span>], c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="number">0</span>], [bottom - <span class="number">0.5</span>, up + <span class="number">0.5</span>], c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    cross = window_cross(line_a, line_b, line_c)</span><br><span class="line">    plt.plot([cross[<span class="number">0</span>][<span class="number">0</span>], cross[<span class="number">1</span>][<span class="number">0</span>]], [cross[<span class="number">0</span>][<span class="number">1</span>], cross[<span class="number">1</span>][<span class="number">1</span>]], c=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    <span class="comment"># 暂停</span></span><br><span class="line">    <span class="keyword">if</span> ii &lt; <span class="number">8</span>:</span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line">    <span class="comment"># 迭代更新</span></span><br><span class="line">    line_a, line_b, line_c = line_a+point_coordinates[<span class="number">0</span>], line_b+point_coordinates[<span class="number">0</span>], line_c + <span class="number">1</span></span><br><span class="line">    class_dots = np.array([<span class="number">1</span> <span class="keyword">if</span> np.dot(xi, [line_a, line_b]) + line_c &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> dots])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭交互模式</span></span><br><span class="line">plt.ioff()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图形显示</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对偶形式的学习&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="感知机" scheme="https://du2279664786.github.io/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>随机 梯度下降--感知机实现</title>
    <link href="https://du2279664786.github.io/2021/11/10/2021-11-10%E2%80%9C%E9%9A%8F%E6%9C%BA%E2%80%9D%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D--%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0/"/>
    <id>https://du2279664786.github.io/2021/11/10/2021-11-10%E2%80%9C%E9%9A%8F%E6%9C%BA%E2%80%9D%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D--%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-10T14:55:10.000Z</published>
    <updated>2022-10-16T13:48:38.298Z</updated>
    
    <content type="html"><![CDATA[<p>要理解梯度下降和“随机”梯度下降的区别。</p><span id="more"></span><h2 id="随机梯度下降特点："><a href="#随机梯度下降特点：" class="headerlink" title="随机梯度下降特点："></a>随机梯度下降特点：</h2><p> ·每次更新数据只选取一个样本</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><p>   ·相比于批量梯度，这样的方法更快，更快收敛，虽然不是全局最优，但很多时候是我们可以接受的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>数据的准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x = np.array([[-1., 2.], [0., 0.], [0., 2.], [1., 0]])</span></span><br><span class="line">x = np.array([[<span class="number">0.</span>, <span class="number">2.</span>], [<span class="number">1.</span>, <span class="number">0</span>], [-<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"><span class="comment"># y = np.array([1, 1, -1, -1])</span></span><br><span class="line">y = np.array([-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>可视化函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_plot</span>(<span class="params">x, omega, b</span>):</span><br><span class="line">    xx = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">    yy = - <span class="number">1</span> / omega[<span class="number">1</span>] * (omega[<span class="number">0</span>] * xx + b)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=y)</span><br><span class="line">    plt.plot(xx, yy)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;(&#123;&#125;) * x1 + (&#123;&#125;) * x2 + (&#123;&#125;) = 0&#x27;</span>.<span class="built_in">format</span>(*omega, b))</span><br><span class="line">    plt.xlim(-<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    plt.ylim(-<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    plt.grid()</span><br></pre></td></tr></table></figure><p>随机初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">omega = np.array([<span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">b = <span class="number">0.0</span></span><br><span class="line">eta = <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>感知机函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">pp, b, omega</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sign(np.dot(pp, omega) + b)</span><br></pre></td></tr></table></figure><p>定义判断感知机分类对错的函数（选取错的点来优化）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">error_value</span>(<span class="params">x, y</span>):</span><br><span class="line">    x_f = []</span><br><span class="line">    y_f = []</span><br><span class="line"></span><br><span class="line">    check = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check:</span><br><span class="line">        check = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> xi, yi <span class="keyword">in</span> <span class="built_in">zip</span>(x, y):</span><br><span class="line">            <span class="keyword">if</span> sign(xi, b, omega) * yi &lt;= <span class="number">0</span>:</span><br><span class="line">                x_f.append(xi)</span><br><span class="line">                y_f.append(yi)</span><br><span class="line">    <span class="keyword">return</span> x_f, y_f</span><br></pre></td></tr></table></figure><p>进行判断和优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">check = <span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> check:</span><br><span class="line">    x_f, y_f = error_value(x, y)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x_f) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;最终梯度下降得到的omega和b分别是：&quot;</span>, omega, b)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index = np.random.randint(<span class="number">0</span>, <span class="built_in">len</span>(x_f), <span class="number">1</span>)[<span class="number">0</span>]   <span class="comment"># 体现出&quot;随机&quot;</span></span><br><span class="line">    x_tem = x_f[index]</span><br><span class="line">    y_tem = y_f[index]</span><br><span class="line">    omega = omega - eta * (-np.dot(x_tem, y_tem))   <span class="comment"># 体现出&quot;梯度下降&quot;</span></span><br><span class="line">    b = b - eta * (-y_tem)</span><br><span class="line"><span class="comment">#     print(omega)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&#123;0&#125;此迭代分错的样本为:&quot;</span>.<span class="built_in">format</span>(i), x_f)</span><br><span class="line">    i+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>Out</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>]), array([<span class="number">1.</span>, <span class="number">0.</span>]), array([-<span class="number">1.</span>,  <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">2</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>]), array([<span class="number">1.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">3</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">4</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">5</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">6</span>此迭代分错的样本为: [array([-<span class="number">1.</span>,  <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">7</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">8</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>])]</span><br><span class="line">第<span class="number">9</span>此迭代分错的样本为: [array([-<span class="number">1.</span>,  <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">10</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>])]</span><br><span class="line">第<span class="number">11</span>此迭代分错的样本为: [array([-<span class="number">1.</span>,  <span class="number">2.</span>]), array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">第<span class="number">12</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">2.</span>])]</span><br><span class="line">第<span class="number">13</span>此迭代分错的样本为: [array([<span class="number">0.</span>, <span class="number">0.</span>])]</span><br><span class="line">最终梯度下降得到的omega和b分别是： [-<span class="number">5.</span> -<span class="number">2.</span>] <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_plot(x, omega, b)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/37ff5d54542c4c749d50568d6533d110.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可改进之处：在“进行判断和优化”的代码里面直接打乱数据的顺序，使得能够随机选取一个数进行优化</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要理解梯度下降和“随机”梯度下降的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="感知机" scheme="https://du2279664786.github.io/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    
    <category term="梯度下降" scheme="https://du2279664786.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降--感知机实现</title>
    <link href="https://du2279664786.github.io/2021/11/09/2021-11-09%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D--%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0/"/>
    <id>https://du2279664786.github.io/2021/11/09/2021-11-09%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D--%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-09T14:55:10.000Z</published>
    <updated>2022-10-16T13:37:56.155Z</updated>
    
    <content type="html"><![CDATA[<p>用梯度下降法来优化感知机模型</p><span id="more"></span><h1 id="任务：用梯度下降的方法优化感知机"><a href="#任务：用梯度下降的方法优化感知机" class="headerlink" title="任务：用梯度下降的方法优化感知机"></a>任务：用梯度下降的方法优化感知机</h1><p>首先导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先导入包：</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>数据的准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x = np.array([[-1., 2.], [0., 0.], [0., 2.], [1., 0]])</span></span><br><span class="line">x = np.array([[<span class="number">0.</span>, <span class="number">2.</span>], [<span class="number">1.</span>, <span class="number">0</span>], [-<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"><span class="comment"># y = np.array([1, 1, -1, -1])</span></span><br><span class="line">y = np.array([-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>可视化函数的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_plot</span>(<span class="params">x, omega, b</span>):</span><br><span class="line">    xx = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">    yy = - <span class="number">1</span> / omega[<span class="number">1</span>] * (omega[<span class="number">0</span>] * xx + b)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=y)</span><br><span class="line">    plt.plot(xx, yy)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;(&#123;&#125;) * x1 + (&#123;&#125;) * x2 + (&#123;&#125;) = 0&#x27;</span>.<span class="built_in">format</span>(*omega, b))</span><br><span class="line">    plt.xlim(-<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    plt.ylim(-<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    plt.grid()</span><br></pre></td></tr></table></figure><p>随机初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">omega = np.array([<span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">b = <span class="number">0.0</span></span><br><span class="line">eta = <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>感知机函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">pp, b, omega</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sign(np.dot(pp, omega) + b)</span><br></pre></td></tr></table></figure><p>实现梯度下降</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">check = <span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> check:</span><br><span class="line">    check = <span class="literal">True</span></span><br><span class="line">    ter = <span class="built_in">list</span>(<span class="built_in">zip</span>(x, y))</span><br><span class="line">    np.random.shuffle(ter)</span><br><span class="line">    np.random.seed(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(ter)</span><br><span class="line">    <span class="keyword">for</span> xi, yi <span class="keyword">in</span> ter:</span><br><span class="line">        <span class="keyword">if</span> sign(xi, b, omega) * yi &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(xi)</span><br><span class="line">            <span class="built_in">print</span>(omega, b)</span><br><span class="line">            omega += eta * xi * yi</span><br><span class="line">            b += eta * yi</span><br><span class="line">            <span class="built_in">print</span>(omega, b)</span><br><span class="line">            check = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">plot_plot(x, omega, b)</span><br></pre></td></tr></table></figure><p>最终优化的曲结果<img src="https://img-blog.csdnimg.cn/855b3b90f7904984b9d4527a24b37493.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用梯度下降法来优化感知机模型&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="感知机" scheme="https://du2279664786.github.io/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    
    <category term="梯度下降" scheme="https://du2279664786.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>系统认证风险预测-Baseline</title>
    <link href="https://du2279664786.github.io/2021/11/08/2021-11-08%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81%E9%A3%8E%E9%99%A9%E9%A2%84%E6%B5%8B-Baseline/"/>
    <id>https://du2279664786.github.io/2021/11/08/2021-11-08%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81%E9%A3%8E%E9%99%A9%E9%A2%84%E6%B5%8B-Baseline/</id>
    <published>2021-11-08T14:55:10.000Z</published>
    <updated>2022-10-16T02:43:14.578Z</updated>
    
    <content type="html"><![CDATA[<p>构建用户认证行为特征模型和风险异常评估模型，利用风险评估模型去判断当前用户认证行为是否存在风险</p><span id="more"></span><h1 id="比赛任务"><a href="#比赛任务" class="headerlink" title="比赛任务"></a>比赛任务</h1><p>本赛题中，参赛团队将基于用户认证行为数据及风险异常标记结构，构建用户认证行为特征模型和风险异常评估模型，利用风险评估模型去判断当前用户认证行为是否存在风险</p><pre><code>利用用户认证数据构建行为基采用监督学习模型，基于用户认证行为特征，构建风险异常评估模型，判断当前用户认证行为是否存在风险</code></pre><h1 id="比赛数据集"><a href="#比赛数据集" class="headerlink" title="比赛数据集"></a>比赛数据集</h1><p><a href="https://www.heywhale.com/mw/dataset/6189288bebdfaf0017562059/file">https://www.heywhale.com/mw/dataset/6189288bebdfaf0017562059/file</a></p><h1 id="赛题baseline："><a href="#赛题baseline：" class="headerlink" title="赛题baseline："></a>赛题baseline：</h1><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.simplefilter(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.set_option(<span class="string">&#x27;max_columns&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;max_rows&#x27;</span>, <span class="number">200</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.3f&#x27;</span> % x)</span><br><span class="line"><span class="keyword">from</span> tqdm.notebook <span class="keyword">import</span> tqdm </span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold, StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler, MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br></pre></td></tr></table></figure><p>合并数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&quot;E://data//DF//CCK-系统认证风险预测/train_dataset.csv&quot;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">test = pd.read_csv(<span class="string">&#x27;E://data//DF//CCK-系统认证风险预测/test_dataset.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">data = pd.concat([train, test])</span><br></pre></td></tr></table></figure><p>特征转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;location_first_lvl&#x27;</span>] = data[<span class="string">&#x27;location&#x27;</span>].astype(<span class="built_in">str</span>).apply(<span class="keyword">lambda</span> x: json.loads(x)[<span class="string">&#x27;first_lvl&#x27;</span>])</span><br><span class="line">data[<span class="string">&#x27;location_sec_lvl&#x27;</span>] = data[<span class="string">&#x27;location&#x27;</span>].astype(<span class="built_in">str</span>).apply(<span class="keyword">lambda</span> x: json.loads(x)[<span class="string">&#x27;sec_lvl&#x27;</span>])</span><br><span class="line">data[<span class="string">&#x27;location_third_lvl&#x27;</span>] = data[<span class="string">&#x27;location&#x27;</span>].astype(<span class="built_in">str</span>).apply(<span class="keyword">lambda</span> x: json.loads(x)[<span class="string">&#x27;third_lvl&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data[<span class="string">&#x27;auth_type&#x27;</span>].fillna(<span class="string">&#x27;__NaN__&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> tqdm([<span class="string">&#x27;user_name&#x27;</span>, <span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;auth_type&#x27;</span>, <span class="string">&#x27;ip&#x27;</span>, </span><br><span class="line">                 <span class="string">&#x27;ip_location_type_keyword&#x27;</span>, <span class="string">&#x27;ip_risk_level&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;device_model&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;os_type&#x27;</span>, <span class="string">&#x27;os_version&#x27;</span>, <span class="string">&#x27;browser_type&#x27;</span>, <span class="string">&#x27;browser_version&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;bus_system_code&#x27;</span>, <span class="string">&#x27;op_target&#x27;</span>, <span class="string">&#x27;location_first_lvl&#x27;</span>, <span class="string">&#x27;location_sec_lvl&#x27;</span>, </span><br><span class="line">                 <span class="string">&#x27;location_third_lvl&#x27;</span>]):</span><br><span class="line">    lbl = LabelEncoder()</span><br><span class="line">    data[col] = lbl.fit_transform(data[col])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;op_date&#x27;</span>] = pd.to_datetime(data[<span class="string">&#x27;op_date&#x27;</span>])</span><br><span class="line">data[<span class="string">&#x27;op_ts&#x27;</span>] = data[<span class="string">&quot;op_date&quot;</span>].values.astype(np.int64) // <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line"><span class="comment"># data[&quot;op_date&quot;].values.astype(np.int64)</span></span><br><span class="line"><span class="comment"># data = data.sort_values(by=[&#x27;user_name&#x27;, &#x27;op_ts&#x27;, &quot;action&quot;]).reset_index(drop=True)</span></span><br><span class="line">data = data.sort_values(by=[<span class="string">&#x27;user_name&#x27;</span>, <span class="string">&#x27;op_ts&#x27;</span>, <span class="string">&quot;action&quot;</span>]).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># data[&#x27;last_ts&#x27;] = data.groupby([&#x27;user_name&#x27;,&quot;action&quot;])[&#x27;op_ts&#x27;].shift(1)</span></span><br><span class="line">data[<span class="string">&#x27;last_ts&#x27;</span>] = data.groupby([<span class="string">&#x27;user_name&#x27;</span>])[<span class="string">&#x27;op_ts&#x27;</span>].shift(<span class="number">1</span>)</span><br><span class="line">data[<span class="string">&#x27;ts_diff1&#x27;</span>] = data[<span class="string">&#x27;op_ts&#x27;</span>] - data[<span class="string">&#x27;last_ts&#x27;</span>]</span><br><span class="line">data[<span class="string">&quot;weekday&quot;</span>] = data[<span class="string">&quot;op_date&quot;</span>].dt.dayofweek+<span class="number">1</span></span><br><span class="line"><span class="comment"># data.groupby(&quot;weekday&quot;)[&quot;ts_diff1&quot;].sum()</span></span><br><span class="line">data[<span class="string">&quot;year&quot;</span>] = data[<span class="string">&quot;op_date&quot;</span>].dt.year</span><br><span class="line">data[<span class="string">&quot;year&quot;</span>] = data[<span class="string">&quot;year&quot;</span>].<span class="built_in">map</span>(&#123;<span class="number">2018</span>:<span class="number">0</span>, <span class="number">2019</span>:<span class="number">1</span>, <span class="number">2020</span>:<span class="number">2</span>&#125;)</span><br><span class="line">data[<span class="string">&quot;month&quot;</span>] = data[<span class="string">&quot;op_date&quot;</span>].dt.month</span><br><span class="line">data[<span class="string">&quot;day&quot;</span>] = data[<span class="string">&quot;op_date&quot;</span>].dt.day</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特征构建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&quot;ts_diff1_log&quot;</span>] = data[<span class="string">&quot;ts_diff1&quot;</span>].apply(np.log)</span><br><span class="line">data[<span class="string">&quot;ts_diff1_log_log&quot;</span>] = data[<span class="string">&quot;ts_diff1&quot;</span>].apply(np.log).apply(np.log)</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> [<span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;device_model&#x27;</span>, <span class="string">&#x27;os_version&#x27;</span>]:</span><br><span class="line">    data[<span class="string">f&#x27;user_<span class="subst">&#123;f&#125;</span>_nunique&#x27;</span>] = data.groupby([<span class="string">&#x27;user_name&#x27;</span>,<span class="string">&quot;action&quot;</span>])[f].transform(<span class="string">&#x27;nunique&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> method <span class="keyword">in</span> [<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;std&#x27;</span>,<span class="string">&quot;prod&quot;</span>]:</span><br><span class="line">    data[<span class="string">f&#x27;ts_diff1_<span class="subst">&#123;method&#125;</span>&#x27;</span>] = data.groupby([<span class="string">&#x27;user_name&#x27;</span>,<span class="string">&quot;action&quot;</span>])[<span class="string">&#x27;ts_diff1&#x27;</span>].transform(method)</span><br><span class="line"></span><br><span class="line">=```</span><br><span class="line">构建与标签相关性高的数据（但是并没有业务意义）</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">data[<span class="string">&quot;auth_type//ip_risk_level&quot;</span>] = data[<span class="string">&quot;auth_type&quot;</span>]/data[<span class="string">&quot;ip_risk_level&quot;</span>]</span><br><span class="line">data[<span class="string">&quot;ip_risk_level//auth_type&quot;</span>] = data[<span class="string">&quot;ip_risk_level&quot;</span>]/data[<span class="string">&quot;auth_type&quot;</span>]</span><br><span class="line">data[<span class="string">&quot;browser_type//auth_type&quot;</span>] = data[<span class="string">&quot;browser_type&quot;</span>]/data[<span class="string">&quot;auth_type&quot;</span>]</span><br><span class="line">data[<span class="string">&quot;browser_version//auth_type&quot;</span>] = data[<span class="string">&quot;browser_version&quot;</span>]/data[<span class="string">&quot;auth_type&quot;</span>]</span><br></pre></td></tr></table></figure><p>查看相关性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data.corr()[<span class="string">&quot;risk_label&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与标签的相关性</span></span><br><span class="line">ip_risk_level//auth_type     -<span class="number">0.032</span></span><br><span class="line">auth_type//ip_risk_level     -<span class="number">0.028</span></span><br><span class="line">browser_type//auth_type      -<span class="number">0.025</span></span><br><span class="line">browser_version//auth_type   -<span class="number">0.021</span></span><br><span class="line">op_ts                        -<span class="number">0.021</span></span><br><span class="line">last_ts                      -<span class="number">0.021</span></span><br><span class="line">year                         -<span class="number">0.017</span></span><br><span class="line">browser_version              -<span class="number">0.009</span></span><br><span class="line">browser_type                 -<span class="number">0.009</span></span><br><span class="line">weekday                      -<span class="number">0.009</span></span><br><span class="line">day                          -<span class="number">0.008</span></span><br><span class="line">month                        -<span class="number">0.008</span></span><br><span class="line">ip_risk_level                -<span class="number">0.007</span></span><br><span class="line">auth_type                    -<span class="number">0.006</span></span><br></pre></td></tr></table></figure><p>删除没用的特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">&#x27;client_type&#x27;</span>, <span class="string">&#x27;browser_source&#x27;</span>, <span class="string">&quot;user_name&quot;</span>, <span class="string">&quot;bus_system_code&quot;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># data.drop([&#x27;client_type&#x27;, &#x27;browser_source&#x27;, &quot;browser_type&quot;], axis=1, inplace=True)</span></span><br><span class="line">train = data[data[<span class="string">&#x27;risk_label&#x27;</span>].notna()]</span><br><span class="line">test = data[data[<span class="string">&#x27;risk_label&#x27;</span>].isna()]</span><br></pre></td></tr></table></figure><p>查看相关性热力图<br><img src="https://img-blog.csdnimg.cn/b43c525d72b94d4a91f3acf38d98410a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>选取feature_names</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ycol = <span class="string">&#x27;risk_label&#x27;</span></span><br><span class="line">feature_names = <span class="built_in">list</span>(</span><br><span class="line">    <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x <span class="keyword">not</span> <span class="keyword">in</span> [ycol, <span class="string">&#x27;session_id&#x27;</span>, <span class="string">&#x27;op_date&#x27;</span>, <span class="string">&#x27;last_ts&#x27;</span>], train.columns))</span><br></pre></td></tr></table></figure><p>训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">model = lgb.LGBMClassifier(objective=<span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">                           boosting_type=<span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">                           tree_learner=<span class="string">&#x27;serial&#x27;</span>,</span><br><span class="line">                           num_leaves=<span class="number">32</span>,</span><br><span class="line">                           max_depth=<span class="number">6</span>,</span><br><span class="line">                           learning_rate=<span class="number">0.05</span>,</span><br><span class="line">                           n_estimators=<span class="number">3000</span>,</span><br><span class="line">                           subsample=<span class="number">0.8</span>,</span><br><span class="line">                           feature_fraction=<span class="number">0.6</span>,</span><br><span class="line">                           reg_alpha=<span class="number">0.</span>,</span><br><span class="line">                           reg_lambda=<span class="number">0.</span>,</span><br><span class="line">                           random_state=<span class="number">1983</span>,</span><br><span class="line">                           is_unbalance=<span class="literal">True</span>,</span><br><span class="line">                           metric=<span class="string">&#x27;auc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">oof = []</span><br><span class="line">prediction = test[[<span class="string">&#x27;session_id&#x27;</span>]]</span><br><span class="line">prediction[ycol] = <span class="number">0</span></span><br><span class="line">df_importance_list = []</span><br><span class="line"></span><br><span class="line">kfold = StratifiedKFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">1983</span>)</span><br><span class="line"><span class="keyword">for</span> fold_id, (trn_idx, val_idx) <span class="keyword">in</span> <span class="built_in">enumerate</span>(kfold.split(train[feature_names], train[ycol])):</span><br><span class="line">    X_train = train.iloc[trn_idx][feature_names]</span><br><span class="line">    Y_train = train.iloc[trn_idx][ycol]</span><br><span class="line"></span><br><span class="line">    X_val = train.iloc[val_idx][feature_names]</span><br><span class="line">    Y_val = train.iloc[val_idx][ycol]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nFold_&#123;&#125; Training ================================\n&#x27;</span>.<span class="built_in">format</span>(fold_id+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    lgb_model = model.fit(X_train,</span><br><span class="line">                          Y_train,</span><br><span class="line">                          eval_names=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>],</span><br><span class="line">                          eval_set=[(X_train, Y_train), (X_val, Y_val)],</span><br><span class="line">                          verbose=<span class="number">500</span>,</span><br><span class="line">                          eval_metric=<span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">                          early_stopping_rounds=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    pred_val = lgb_model.predict_proba(</span><br><span class="line">        X_val, num_iteration=lgb_model.best_iteration_)</span><br><span class="line">    df_oof = train.iloc[val_idx][[<span class="string">&#x27;session_id&#x27;</span>, ycol]].copy()</span><br><span class="line">    df_oof[<span class="string">&#x27;pred&#x27;</span>] = pred_val[:, <span class="number">1</span>]</span><br><span class="line">    oof.append(df_oof)</span><br><span class="line"></span><br><span class="line">    pred_test = lgb_model.predict_proba(</span><br><span class="line">        test[feature_names], num_iteration=lgb_model.best_iteration_)</span><br><span class="line">    prediction[ycol] += pred_test[:, <span class="number">1</span>] / kfold.n_splits</span><br><span class="line"></span><br><span class="line">    df_importance = pd.DataFrame(&#123;</span><br><span class="line">        <span class="string">&#x27;column&#x27;</span>: feature_names,</span><br><span class="line">        <span class="string">&#x27;importance&#x27;</span>: lgb_model.feature_importances_,</span><br><span class="line">    &#125;)</span><br><span class="line">    df_importance_list.append(df_importance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> lgb_model, pred_val, pred_test, X_train, Y_train, X_val, Y_val</span><br><span class="line">    gc.collect()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">df_importance = pd.concat(df_importance_list)</span><br><span class="line">df_importance = df_importance.groupby([<span class="string">&#x27;column&#x27;</span>])[<span class="string">&#x27;importance&#x27;</span>].agg(</span><br><span class="line">    <span class="string">&#x27;mean&#x27;</span>).sort_values(ascending=<span class="literal">False</span>).reset_index()</span><br><span class="line">df_oof = pd.concat(oof)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;roc_auc_score&#x27;</span>, roc_auc_score(df_oof[ycol], df_oof[<span class="string">&#x27;pred&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">## roc_auc_score 0.5131761316649879</span></span><br><span class="line"></span><br><span class="line">prediction[<span class="string">&#x27;id&#x27;</span>] = <span class="built_in">range</span>(<span class="built_in">len</span>(prediction))</span><br><span class="line">prediction[<span class="string">&#x27;id&#x27;</span>] = prediction[<span class="string">&#x27;id&#x27;</span>] + <span class="number">1</span></span><br><span class="line">prediction = prediction[[<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;risk_label&#x27;</span>]].copy()</span><br><span class="line">prediction.columns = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ret&#x27;</span>]</span><br><span class="line">prediction.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> ret</span><br><span class="line"><span class="number">6147</span> <span class="number">1</span> <span class="number">0.378</span></span><br><span class="line"><span class="number">6148</span> <span class="number">2</span> <span class="number">0.488</span></span><br><span class="line"><span class="number">6149</span> <span class="number">3</span> <span class="number">0.502</span></span><br><span class="line"><span class="number">6150</span> <span class="number">4</span> <span class="number">0.509</span></span><br><span class="line"><span class="number">6151</span> <span class="number">5</span> <span class="number">0.480</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;构建用户认证行为特征模型和风险异常评估模型，利用风险评估模型去判断当前用户认证行为是否存在风险&lt;/p&gt;</summary>
    
    
    
    <category term="竞赛" scheme="https://du2279664786.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据挖掘" scheme="https://du2279664786.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降算介绍以及代码详解</title>
    <link href="https://du2279664786.github.io/2021/10/22/2021-10-22%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>https://du2279664786.github.io/2021/10/22/2021-10-22%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-10-22T14:55:10.000Z</published>
    <updated>2022-10-16T02:40:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>梯度下降法是一个一阶最优化算法。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。 </p><span id="more"></span><h2 id="什么是梯度下降："><a href="#什么是梯度下降：" class="headerlink" title="什么是梯度下降："></a>什么是梯度下降：</h2><p>首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处</p><h2 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h2><p><img src="https://img-blog.csdnimg.cn/0b195a289c0e40118074af94f03035ba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6eebb019bdbe4786a9937003481a98d4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="梯度下降伪代码-个人感觉第-5-步应该转第-2-步-："><a href="#梯度下降伪代码-个人感觉第-5-步应该转第-2-步-：" class="headerlink" title="梯度下降伪代码(个人感觉第(5)步应该转第(2)步)："></a>梯度下降伪代码(个人感觉第(5)步应该转第(2)步)：</h2><p><img src="https://img-blog.csdnimg.cn/b226c05dafef44488d551d507a378622.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先初始化函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span> + <span class="number">10</span> * np.sin(x)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后初始化梯度函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x + <span class="number">10</span> * np.cos(x)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个阈值</span></span><br><span class="line">value = <span class="number">10e-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化起始点</span></span><br><span class="line">k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    grad = df(k)</span><br><span class="line"><span class="comment">#     print(grad)</span></span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">abs</span>(df(k)) &lt; value:</span><br><span class="line">        x_mark = k</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 找出最合适的学习率</span></span><br><span class="line">        Lambda = np.linspace(<span class="number">0</span>, <span class="number">12</span>, <span class="number">10000000</span>)</span><br><span class="line">        tem = k-Lambda * grad       <span class="comment"># 直接减去的梯度的方向，</span></span><br><span class="line">        base_Lambda = Lambda[np.argmin(f(tem))]</span><br><span class="line"><span class="comment">#         print(&quot;最佳的学习率为&quot;, Lambda[np.argmin(f(tem))])</span></span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">abs</span>(k - (k-base_Lambda * grad)) &lt; value <span class="keyword">or</span> np.<span class="built_in">abs</span>(f(k) - f(k-base_Lambda * grad)) &lt; value:</span><br><span class="line">        x_mark = k-base_Lambda * grad</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    k = k-base_Lambda * grad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;局部最优的坐标X值为：&quot;</span>,x_mark)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;局部最优的学习率为：&quot;</span>, base_Lambda)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Out：</span><br><span class="line">局部最优的坐标X值为： <span class="number">3.837467103051607</span></span><br><span class="line">局部最优的学习率为： <span class="number">11.37973433797343</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;梯度下降法是一个一阶最优化算法。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。 &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="梯度下降算法" scheme="https://du2279664786.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kmeans实战-实现二维的bolo分析</title>
    <link href="https://du2279664786.github.io/2021/10/21/2021-10-21Kmeans%E5%AE%9E%E6%88%98-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%9A%84bolo%E5%88%86%E6%9E%90/"/>
    <id>https://du2279664786.github.io/2021/10/21/2021-10-21Kmeans%E5%AE%9E%E6%88%98-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%9A%84bolo%E5%88%86%E6%9E%90/</id>
    <published>2021-10-21T14:55:10.000Z</published>
    <updated>2022-10-15T15:25:19.815Z</updated>
    
    <content type="html"><![CDATA[<p>对二维的bolo数据集分析与可视化</p><span id="more"></span><h1 id="首先导入包："><a href="#首先导入包：" class="headerlink" title="首先导入包："></a>首先导入包：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt     <span class="comment"># 画图的包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np     </span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> mpl  <span class="comment"># import matplotlib as mpl</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs   <span class="comment"># 产生数据集</span></span><br></pre></td></tr></table></figure><h1 id="默认设置："><a href="#默认设置：" class="headerlink" title="默认设置："></a>默认设置：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;FangSong&#x27;</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span></span><br></pre></td></tr></table></figure><h1 id="进行初始化："><a href="#进行初始化：" class="headerlink" title="进行初始化："></a>进行初始化：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n_samples = <span class="number">1500</span>  <span class="comment"># 生成1500个数据集</span></span><br><span class="line">random_state = <span class="number">170</span>  <span class="comment"># 170这个是随机种子</span></span><br><span class="line">k = <span class="number">3</span>  <span class="comment"># 超参数</span></span><br><span class="line">np.random.seed(<span class="number">26</span>)    <span class="comment">#给numpy设置一个随机种子，保证每次都能产生相同的值</span></span><br><span class="line">X, y = make_blobs(n_samples=n_samples, random_state=random_state)    <span class="comment"># 生成数据集，包括1500个样本</span></span><br><span class="line">ages = np.vstack((X[y == <span class="number">0</span>][:<span class="number">500</span>], X[y == <span class="number">1</span>][:<span class="number">500</span>], X[y == <span class="number">2</span>][:<span class="number">500</span>]))   <span class="comment"># 将数据进行堆叠，shape为(1500, 2)</span></span><br><span class="line">y = np.array(([<span class="number">0</span>] * <span class="number">500</span> + [<span class="number">1</span>] * <span class="number">500</span> + [<span class="number">2</span>] * <span class="number">500</span>))  <span class="comment">#生成0 1 2 各500个</span></span><br></pre></td></tr></table></figure><h1 id="迭代初始化："><a href="#迭代初始化：" class="headerlink" title="迭代初始化："></a>迭代初始化：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">centers = np.zeros([<span class="number">3</span>, <span class="number">2</span>])    <span class="comment"># 生成0矩阵</span></span><br><span class="line">centers_random = np.random.choice(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), <span class="number">3</span>)  <span class="comment"># 迭代起点</span></span><br><span class="line">centers_new = ages[centers_random]   <span class="comment"># 随机选取中心</span></span><br><span class="line">dis_to_cent = np.zeros((k, <span class="built_in">len</span>(ages)))  <span class="comment"># 一个二维数据，相当于一个空的容器</span></span><br></pre></td></tr></table></figure><h1 id="实现预测："><a href="#实现预测：" class="headerlink" title="实现预测："></a>实现预测：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> (centers_new == centers).<span class="built_in">all</span>():</span><br><span class="line">    centers = centers_new.copy()  <span class="comment"># 注意python的赋值过程，进行展开讲解，== is 和复制方式</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        dis_to_cent[ii] = np.linalg.norm(ages - centers[ii], axis=<span class="number">1</span>)    <span class="comment"># 计算每个数值到中心的距离</span></span><br><span class="line"></span><br><span class="line">    clusters = dis_to_cent.argmin(axis=<span class="number">0</span>)   <span class="comment"># 划分出每个类别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(k):   <span class="comment"># 重新计算中心</span></span><br><span class="line">        cluster = ages[clusters == ii]</span><br><span class="line">        centers_new[ii] = ages[clusters == ii].mean(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(centers, centers_new)</span><br><span class="line">    <span class="built_in">print</span>(centers_new)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;centers_new==centers?&#x27;</span>, (centers_new == centers).<span class="built_in">all</span>())</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对二维的bolo数据集分析与可视化&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Kmeans可视化" scheme="https://du2279664786.github.io/tags/Kmeans%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>KMeans算法分析以及可视化展示</title>
    <link href="https://du2279664786.github.io/2021/10/10/2021-10-10KMeans%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA/"/>
    <id>https://du2279664786.github.io/2021/10/10/2021-10-10KMeans%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA/</id>
    <published>2021-10-10T14:55:10.000Z</published>
    <updated>2022-10-15T15:23:27.831Z</updated>
    
    <content type="html"><![CDATA[<p>手动生成数据集并进行可视化</p><span id="more"></span><h1 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> mpl  <span class="comment"># import matplotlib as mpl</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br></pre></td></tr></table></figure><h2 id="画图问题："><a href="#画图问题：" class="headerlink" title="画图问题："></a>画图问题：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;FangSong&#x27;</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span></span><br></pre></td></tr></table></figure><h2 id="数据集的生成"><a href="#数据集的生成" class="headerlink" title="数据集的生成"></a>数据集的生成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n_samples = 1500  # 生成1500个数据集</span><br><span class="line">random_state = 170  # 170这个是随机种子</span><br><span class="line">X, y = make_blobs(n_samples=n_samples, random_state=random_state)    # 生成数据集，包括1500个样本</span><br><span class="line">ages = np.vstack((X[y == 0][:500], X[y == 1][:500], X[y == 2][:500]))   # 将数据进行堆叠，shape为(1500, 2)</span><br><span class="line">y = np.array(([0] * 500 + [1] * 500 + [2] * 500))  #生成0 1 2 各500个</span><br></pre></td></tr></table></figure><h2 id="定义聚类中心："><a href="#定义聚类中心：" class="headerlink" title="定义聚类中心："></a>定义聚类中心：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">3</span>  <span class="comment"># 超参数</span></span><br></pre></td></tr></table></figure><h2 id="随机种子"><a href="#随机种子" class="headerlink" title="随机种子"></a>随机种子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">26</span>)    <span class="comment">#给numpy设置一个随机种子，保证每次都能产生相同的值</span></span><br></pre></td></tr></table></figure><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">centers = np.zeros([<span class="number">3</span>, <span class="number">2</span>])    <span class="comment"># 生成0矩阵</span></span><br><span class="line">centers_random = np.random.choice(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), <span class="number">3</span>)  <span class="comment"># 迭代起点</span></span><br><span class="line">centers_new = ages[centers_random]   <span class="comment"># 随机选取中心</span></span><br><span class="line">dis_to_cent = np.zeros((k, <span class="built_in">len</span>(ages)))  <span class="comment"># 一个二维数据，相当于一个空的容器</span></span><br></pre></td></tr></table></figure><h2 id="进行聚类中心的判断："><a href="#进行聚类中心的判断：" class="headerlink" title="进行聚类中心的判断："></a>进行聚类中心的判断：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> (centers_new == centers).<span class="built_in">all</span>():</span><br><span class="line">    centers = centers_new.copy()  <span class="comment"># 注意python的赋值过程，进行展开讲解，== is 和复制方式，这里是浅拷贝</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        dis_to_cent[ii] = np.linalg.norm(ages - centers[ii], axis=<span class="number">1</span>)    <span class="comment"># 计算每个数值到中心的距离</span></span><br><span class="line"></span><br><span class="line">    clusters = dis_to_cent.argmin(axis=<span class="number">0</span>)   <span class="comment"># 划分出每个类别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(k):   <span class="comment"># 重新计算中心</span></span><br><span class="line">        cluster = ages[clusters == ii]</span><br><span class="line">        centers_new[ii] = ages[clusters == ii].mean(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(centers, centers_new)</span><br><span class="line">    <span class="built_in">print</span>(centers_new)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;centers_new==centers?&#x27;</span>, (centers_new == centers).<span class="built_in">all</span>())</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="最后实现可视化的展示："><a href="#最后实现可视化的展示：" class="headerlink" title="最后实现可视化的展示："></a>最后实现可视化的展示：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))   <span class="comment">#创建画布</span></span><br><span class="line">ax = plt.subplot(<span class="number">121</span>)  <span class="comment"># 几行，几列，第几个，先按行数</span></span><br><span class="line">ax.scatter(ages[:, <span class="number">0</span>], ages[:, <span class="number">1</span>], c=y)  <span class="comment"># x, y, 颜色，系统有基本的选择机制，不用写得太细</span></span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;数据本身的标签&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax = plt.subplot(<span class="number">122</span>)  <span class="comment"># 几行，几列，第几个，先按行数</span></span><br><span class="line">ax.scatter(ages[:, <span class="number">0</span>], ages[:, <span class="number">1</span>], c=clusters)  <span class="comment"># x, y, 颜色，系统有基本的选择机制，不用写得太细</span></span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;聚类的结果&#x27;</span>)**</span><br></pre></td></tr></table></figure><h2 id="可视化的结果："><a href="#可视化的结果：" class="headerlink" title="可视化的结果："></a>可视化的结果：</h2><p><img src="https://img-blog.csdnimg.cn/43e3ae4a0ea548ffb2550a154cfca28b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;手动生成数据集并进行可视化&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Kmeans" scheme="https://du2279664786.github.io/tags/Kmeans/"/>
    
  </entry>
  
  <entry>
    <title>KNN实现鸢尾花数据集的可视化</title>
    <link href="https://du2279664786.github.io/2021/10/09/2021-10-09KNN%E5%AE%9E%E7%8E%B0%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://du2279664786.github.io/2021/10/09/2021-10-09KNN%E5%AE%9E%E7%8E%B0%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2021-10-09T14:55:10.000Z</published>
    <updated>2022-10-15T14:57:13.550Z</updated>
    
    <content type="html"><![CDATA[<p>kNN实现鸢尾花可视化代码</p><span id="more"></span><h1 id="首先导入包："><a href="#首先导入包：" class="headerlink" title="首先导入包："></a>首先导入包：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br></pre></td></tr></table></figure><h1 id="获取数据："><a href="#获取数据：" class="headerlink" title="获取数据："></a>获取数据：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()  <span class="comment"># 加载数据</span></span><br><span class="line">X = iris.data[:, (<span class="number">1</span>, <span class="number">3</span>)]  <span class="comment"># 为方便画图，仅采用数据的其中两个特征</span></span><br><span class="line">y = iris.target</span><br></pre></td></tr></table></figure><h1 id="设置画图的颜色深浅："><a href="#设置画图的颜色深浅：" class="headerlink" title="设置画图的颜色深浅："></a>设置画图的颜色深浅：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmap_light = ListedColormap([<span class="string">&#x27;#FFAAAA&#x27;</span>, <span class="string">&#x27;#AAFFAA&#x27;</span>, <span class="string">&#x27;#AAAAFF&#x27;</span>])</span><br><span class="line">cmap_bold = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#00FF00&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="决策边界，用不同的颜色表示："><a href="#决策边界，用不同的颜色表示：" class="headerlink" title="决策边界，用不同的颜色表示："></a>决策边界，用不同的颜色表示：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">0.1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">0.1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">0.1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">0.1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br></pre></td></tr></table></figure><h1 id="KNN原理："><a href="#KNN原理：" class="headerlink" title="KNN原理："></a>KNN原理：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knn_code</span>(<span class="params">loc, k=<span class="number">5</span>, order=<span class="number">2</span> </span>):  <span class="comment"># k order是超参</span></span><br><span class="line">    diff_loc = X - loc</span><br><span class="line">    dis_loc = np.linalg.norm(diff_loc, <span class="built_in">ord</span>=order, axis=<span class="number">1</span>) <span class="comment"># 没有axis得到一个数，矩阵的泛数。axis=0，得到两个数</span></span><br><span class="line">    knn = y[dis_loc.argsort()[:k]]</span><br><span class="line">    counts = np.bincount(knn)</span><br><span class="line">    <span class="keyword">return</span> np.argmax(counts</span><br></pre></td></tr></table></figure><h1 id="将数据合并："><a href="#将数据合并：" class="headerlink" title="将数据合并："></a>将数据合并：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line_loc = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(xx.ravel(), yy.ravel())))</span><br></pre></td></tr></table></figure><h1 id="进行画图："><a href="#进行画图：" class="headerlink" title="进行画图："></a>进行画图：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">12</span>))  <span class="comment"># 图的尺寸</span></span><br><span class="line"></span><br><span class="line">pos = <span class="number">1</span>  <span class="comment"># 位置计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">6</span>]:</span><br><span class="line">    <span class="keyword">for</span> order <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line"></span><br><span class="line">        Z = np.array([knn_code(ii, k, order) <span class="keyword">for</span> ii <span class="keyword">in</span> line_loc]).reshape(xx.shape)  <span class="comment"># 这个是不支持向量化运算的</span></span><br><span class="line">        ax = plt.subplot(<span class="number">220</span> + pos)  <span class="comment"># 几行，几列，第几个，先按行数</span></span><br><span class="line">        ax.pcolormesh(xx, yy, Z, cmap=cmap_light, shading=<span class="string">&#x27;auto&#x27;</span>)  <span class="comment"># 绘制预测结果图</span></span><br><span class="line">        ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=cmap_bold)  <span class="comment"># 补充训练数据点</span></span><br><span class="line">        ax.set_title(<span class="string">f&#x27;k: <span class="subst">&#123;k&#125;</span>, distance order: <span class="subst">&#123;order&#125;</span>&#x27;</span>)</span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">&#x27;I am a tuner!&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="可视化展示"><a href="#可视化展示" class="headerlink" title="可视化展示:"></a>可视化展示:</h1><p><img src="https://img-blog.csdnimg.cn/895a06844b024714835b82441349e3f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="可视化"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;kNN实现鸢尾花可视化代码&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="KNN可视化" scheme="https://du2279664786.github.io/tags/KNN%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>查找list中出现次数最多的元素</title>
    <link href="https://du2279664786.github.io/2021/09/21/2021-09-21%E8%8E%B7%E5%8F%96List%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B0/"/>
    <id>https://du2279664786.github.io/2021/09/21/2021-09-21%E8%8E%B7%E5%8F%96List%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B0/</id>
    <published>2021-09-21T14:55:10.000Z</published>
    <updated>2022-10-15T15:16:01.779Z</updated>
    
    <content type="html"><![CDATA[<p>用三种方法来查看列表中出现次数最多的元素</p><span id="more"></span><h1 id="·步骤一首先将元素存入词典"><a href="#·步骤一首先将元素存入词典" class="headerlink" title="·步骤一首先将元素存入词典"></a>·步骤一首先将元素存入词典</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> dic.keys():</span><br><span class="line">        dic[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[i] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二 </span></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    i = <span class="built_in">str</span>(i)</span><br><span class="line">    dic[i] = dic.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">dic = Counter(data)</span><br></pre></td></tr></table></figure><h1 id="·步骤二：统计次数："><a href="#·步骤二：统计次数：" class="headerlink" title="·步骤二：统计次数："></a>·步骤二：统计次数：</h1><h3 id="方法一：argman函数"><a href="#方法一：argman函数" class="headerlink" title="方法一：argman函数"></a>方法一：argman函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 添加数据</span><br><span class="line">lis = []</span><br><span class="line">for i in dic:</span><br><span class="line">    lis.append(dic[i])</span><br><span class="line">    </span><br><span class="line">tem = np.array(lis)</span><br><span class="line">print(&quot;在列表中出现最多的那个数是：&quot;,list(dic.keys())[tem.argmax()])</span><br></pre></td></tr></table></figure><h3 id="方法二：argsort方法"><a href="#方法二：argsort方法" class="headerlink" title="方法二：argsort方法"></a>方法二：argsort方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">lis = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">    lis.append(dic[i])</span><br><span class="line">    </span><br><span class="line">tem = np.array(lis)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;在列表中出现最多的那个数是：&quot;</span>,<span class="built_in">list</span>(dic.keys())[tem.argsort()[-<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h3 id="方法三：打擂台法"><a href="#方法三：打擂台法" class="headerlink" title="方法三：打擂台法"></a>方法三：打擂台法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lis = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">    lis.append(dic[i])</span><br><span class="line"></span><br><span class="line">diff = lis[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    <span class="keyword">if</span> i &gt; diff:</span><br><span class="line">        diff = i</span><br><span class="line">        inde = lis.index(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;在列表中出现最多的那个数是：&quot;</span>, <span class="built_in">list</span>(dic.keys())[inde])</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;用三种方法来查看列表中出现次数最多的元素&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法-KNN</title>
    <link href="https://du2279664786.github.io/2021/09/20/2021-09-20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-KNN/"/>
    <id>https://du2279664786.github.io/2021/09/20/2021-09-20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-KNN/</id>
    <published>2021-09-20T14:55:10.000Z</published>
    <updated>2022-10-15T15:17:01.077Z</updated>
    
    <content type="html"><![CDATA[<p>根据knn的步骤写出knn的代码并画出决策边界</p><span id="more"></span><h1 id="·KNN算法的基本过程："><a href="#·KNN算法的基本过程：" class="headerlink" title="·KNN算法的基本过程："></a>·KNN算法的基本过程：</h1><p>1）计算测试数据与各个训练数据之间的距离<br>2）按照距离的递增关系进行排序</p><p>3）选取距离最小的K个点<br>4）确定前K个点所在类别的出现频率<br>5）返回前K个点中出现频率最高的类别作为测试数据的预测分类</p><h1 id="·算法的优缺点"><a href="#·算法的优缺点" class="headerlink" title="·算法的优缺点"></a>·算法的优缺点</h1><p>优点：精度高、对异常值不敏<br>缺点：计算复杂度高、空间复杂度高</p><p>基本实现流程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="comment"># 数据集的划分</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">666</span>, test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 设置邻居数，即n_neighbors的大小</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line">knn.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pre = knn.predict(x_test)</span><br><span class="line"><span class="comment"># print(y_pre=y_test)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, knn.score(x_test, y_pre))</span><br></pre></td></tr></table></figure><h1 id="·手撕KNN代码，刨析KNN原理"><a href="#·手撕KNN代码，刨析KNN原理" class="headerlink" title="·手撕KNN代码，刨析KNN原理"></a>·手撕KNN代码，刨析KNN原理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># %matplotlib inline</span></span><br><span class="line"></span><br><span class="line">iris = load_iris()  <span class="comment"># 加载数据</span></span><br><span class="line">X = iris.data[:, (<span class="number">1</span>, <span class="number">3</span>)]  <span class="comment"># 为方便画图，仅采用数据的其中两个特征</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line">cmap_light = ListedColormap([<span class="string">&#x27;#FFAAAA&#x27;</span>, <span class="string">&#x27;#AAFFAA&#x27;</span>, <span class="string">&#x27;#AAAAFF&#x27;</span>])</span><br><span class="line">cmap_bold = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#00FF00&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 决策边界，用不同颜色表示</span></span><br><span class="line">x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">0.1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">0.1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">0.1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">0.1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knn_code</span>(<span class="params">loc, k=<span class="number">5</span>, order=<span class="number">2</span> </span>):  <span class="comment"># k order是超参</span></span><br><span class="line">    <span class="comment"># print(order)</span></span><br><span class="line">    diff_loc = X - loc</span><br><span class="line">    dis_loc = np.linalg.norm(diff_loc, <span class="built_in">ord</span>=order, axis=<span class="number">1</span>) <span class="comment"># 没有axis得到一个数，矩阵的泛数。axis=0，得到两个数</span></span><br><span class="line">    knn = y[dis_loc.argsort()[:k]]</span><br><span class="line">    counts = np.bincount(knn)</span><br><span class="line">    <span class="keyword">return</span> np.argmax(counts)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line_loc = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(xx.ravel(), yy.ravel())))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">12</span>))  <span class="comment"># 图的尺寸</span></span><br><span class="line"></span><br><span class="line">pos = <span class="number">1</span>  <span class="comment"># 位置计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">6</span>]:</span><br><span class="line">    <span class="keyword">for</span> order <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line">        Z = np.array([knn_code(ii, k, order) <span class="keyword">for</span> ii <span class="keyword">in</span> line_loc]).reshape(xx.shape)  <span class="comment"># 这个是不支持向量化运算的</span></span><br><span class="line">        ax = plt.subplot(<span class="number">220</span> + pos)  <span class="comment"># 几行，几列，第几个，先按行数</span></span><br><span class="line">        ax.pcolormesh(xx, yy, Z, cmap=cmap_light, shading=<span class="string">&#x27;auto&#x27;</span>)  <span class="comment"># 绘制预测结果图</span></span><br><span class="line">        ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=cmap_bold)  <span class="comment"># 补充训练数据点</span></span><br><span class="line">        ax.set_title(<span class="string">f&#x27;k: <span class="subst">&#123;k&#125;</span>, distance order: <span class="subst">&#123;order&#125;</span>&#x27;</span>)</span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">&#x27;I am a tuner!&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>KNN实现鸢尾花可视化<img src="https://img-blog.csdnimg.cn/0e791c3af82341aa966760e72856e78c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据knn的步骤写出knn的代码并画出决策边界&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="KNN" scheme="https://du2279664786.github.io/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法-Logistic Regressi</title>
    <link href="https://du2279664786.github.io/2021/09/03/2021-09-03%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-Logistic%20Regressi%20(1)/"/>
    <id>https://du2279664786.github.io/2021/09/03/2021-09-03%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-Logistic%20Regressi%20(1)/</id>
    <published>2021-09-03T14:55:10.000Z</published>
    <updated>2022-10-15T15:17:48.101Z</updated>
    
    <content type="html"><![CDATA[<p>逻辑回归并不是一个回归算法，它是一个分类算法；通过拟合一个逻辑函数来预测一个离散型因变量的值（预测一个概率值，基于0与1）</p><span id="more"></span><h1 id="·逻辑回归"><a href="#·逻辑回归" class="headerlink" title="·逻辑回归"></a>·逻辑回归</h1><ul><li>与线性回归不同的是，逻辑回归并不是一个回归算法，它是一个分类算法；通过拟合一个逻辑函数来预测一个离散型因变量的值（预测一个概率值，基于0与1），来描述自变量对因变量的影响程度。</li></ul><p>自变量可以有一个，也可以有多个。其中，一个自变量被称为一元逻辑回归，而多个自变量被称为多元逻辑回归。以实例而言，逻辑回归可以预测一封邮件是垃圾邮件的概率是多少。同时，因为结果是概率值，它同样可以对点击率等结果做排名模型预测</p><ul><li>基本代码实现：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 关于逻辑回</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# 首先导入包：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.<span class="property">datasets</span> <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">iris = <span class="title function_">load_iris</span>()</span><br><span class="line"></span><br><span class="line"># 前两列数据（花萼长度与宽度）进行回归分类</span><br><span class="line">X = iris.<span class="property">data</span>[:, :<span class="number">2</span>]</span><br><span class="line">Y = iris.<span class="property">target</span></span><br><span class="line"></span><br><span class="line"># 分割数据集：</span><br><span class="line"><span class="keyword">from</span> sklearn.<span class="property">model_selection</span> <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = <span class="title function_">train_test_split</span>(X, Y, random_state=<span class="number">66</span>, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"># 导入模型， 调佣逻辑回归函数<span class="title class_">LogisticRegrssion</span>()函数</span><br><span class="line"><span class="keyword">from</span> sklearn.<span class="property">linear_model</span> <span class="keyword">import</span> <span class="title class_">LogisticRegression</span></span><br><span class="line"></span><br><span class="line"># 训练模型</span><br><span class="line">lr = <span class="title class_">LogisticRegression</span>(penalty=<span class="string">&quot;l2&quot;</span>, solver=<span class="string">&#x27;newton-cg&#x27;</span>, multi_class=<span class="string">&#x27;multinomial&#x27;</span>)</span><br><span class="line">lr.<span class="title function_">fit</span>(x_train, y_train)</span><br><span class="line"># 关于模型的参数：</span><br><span class="line"># penalty：正则化选择参数，默认方式为 <span class="variable constant_">L2</span> 正则化</span><br><span class="line"># solver：优化算法选择参数，有&#123;‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’&#125;四种参数，如果你是用的是 <span class="variable constant_">L1</span> 正则化，则只能使用 libinear，这是因为 <span class="variable constant_">L1</span> 正则化并不是一个连续可导的损失函数。</span><br><span class="line"># muti_class：分类方式选择参数，包括&#123;‘ovr’, ‘multinomial’&#125;两种参数。简单来说，<span class="title class_">OvR</span> 相对简单，但分类效果相对略差（这里指大多数样本分布情况，某些样本分布下 <span class="title class_">OvR</span> 可能更好）。而 <span class="title class_">MvM</span> 分类相对精确，但是分类速度没有 <span class="title class_">OvR</span> 快。</span><br><span class="line"></span><br><span class="line"># 预测数据</span><br><span class="line">y_pre = lr.<span class="title function_">predict</span>(x_test)</span><br><span class="line"></span><br><span class="line"># 准确率的评估</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;逻辑回归训练集数据的准确率为\n&quot;</span>, lr.<span class="title function_">score</span>(x_train, y_train))</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;逻辑回归测试集数据的准确率为\n&quot;</span>, lr.<span class="title function_">score</span>(x_test, y_test))</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">accuracy = metrics.<span class="title function_">accuracy_score</span>(y_pre, y_test)</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&#x27;逻辑回归模型准确率：%.3f&#x27;</span>% accuracy)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>公众号：欢迎转发和关注本公众号，经常分享一些基础的学习知识。欢迎关注！！！</p><p><img src="https://img-blog.csdnimg.cn/b45ed81227604d569a2ca4f50cfee1aa.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP55qu6bq76Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;逻辑回归并不是一个回归算法，它是一个分类算法；通过拟合一个逻辑函数来预测一个离散型因变量的值（预测一个概率值，基于0与1）&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="逻辑回归" scheme="https://du2279664786.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Pandas基础</title>
    <link href="https://du2279664786.github.io/2021/05/21/2021-05-02-Pandas%E5%9F%BA%E7%A1%80/"/>
    <id>https://du2279664786.github.io/2021/05/21/2021-05-02-Pandas%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-21T14:55:10.000Z</published>
    <updated>2022-10-15T15:18:10.703Z</updated>
    
    <content type="html"><![CDATA[<p>DataFrame是一个表格型的数据结构，它含有一组 有序 的列，每列可以是不同的值类型</p><span id="more"></span><p>DataFrame介绍：</p><p>DataFrame是一个表格型的数据结构，它含有一组 有序 的列，每列可以是不同的值类型（数值、字符串、布尔值等）。</p><p>导入包：</p><p><img src="https://img-blog.csdnimg.cn/20210502192544593.png" alt="在这里插入图片描述"></p><p>  1.将字典转化为DataFrame</p><p>  定义字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&quot;grammer&quot;</span>:[<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;GO&quot;</span>,np.nan,<span class="string">&quot;SQL&quot;</span>,<span class="string">&quot;PHP&quot;</span>,<span class="string">&quot;Python&quot;</span>],</span><br><span class="line">       <span class="string">&quot;score&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>]&#125;</span><br></pre></td></tr></table></figure><p>   将字典转化为DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><pre><code>得到：</code></pre><p> <img src="https://img-blog.csdnimg.cn/20210502192739302.png" alt="在这里插入图片描述"></p><p>2.提取含有字符串“Python”行：</p><p>方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df[df[<span class="string">&#x27;grammer&#x27;</span>] == <span class="string">&#x27;Python&#x27;</span>]</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">results = df[<span class="string">&#x27;grammer&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">results.fillna(value=<span class="literal">False</span>,inplace = <span class="literal">True</span>)</span><br><span class="line">df[results]</span><br></pre></td></tr></table></figure><p>得到的结果：<br><img src="https://img-blog.csdnimg.cn/20210502192812667.png" alt="在这里插入图片描述"></p><p>3.输出列名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.columns)</span><br></pre></td></tr></table></figure><p>得到的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out[<span class="number">28</span>]: Index([<span class="string">&#x27;grammer&#x27;</span>, <span class="string">&#x27;score&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>4.将第二列改成“popularity”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df.rename(columns = &#123;<span class="string">&#x27;score&#x27;</span>:<span class="string">&#x27;popularity&#x27;</span>&#125;, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>输出df：</p><p><img src="https://img-blog.csdnimg.cn/20210502192842315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc1NjEwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>5.统计grammer每一列中编程语言出现的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;grammer&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img-blog.csdnimg.cn/20210502192858266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc1NjEwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>6.提取popularity中大于三的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;score&#x27;</span>]&gt;<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img-blog.csdnimg.cn/20210502192910111.png" alt="在这里插入图片描述"></p><p>7.按照grammer列进行去除重复值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df.drop_duplicates([<span class="string">&#x27;grammer&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210502192948980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc1NjEwNA==,size_16,color_FFFFFF,t_70" alt="图片"></p><p>8.计算popularity列的平均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;score&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><p>9.将grammer列转化为list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df[<span class="string">&#x27;grammer&#x27;</span>].tolist()</span><br></pre></td></tr></table></figure><p>10.将DataFrame保存为csv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">&quot;text.csv&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果得到了一个csv文件：</p><p><img src="https://img-blog.csdnimg.cn/20210502192956593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc1NjEwNA==,size_16,color_FFFFFF,t_70" alt="图片"></p><p><a href="https://www.heywhale.com/mw/project/6047189c89c874001524f6c9?token=43ba0f12bfd74662">task来源于和鲸训练营</a></p>]]></content>
    
    
    <summary type="html">这是显示在首页的概述，正文内容均会被隐藏。</summary>
    
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://du2279664786.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据处理" scheme="https://du2279664786.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
